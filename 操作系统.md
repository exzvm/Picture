## 一、操作系统启动

bootset

setup模块

head

main	---->	mem_init

将操作系统代码放到内存里，从0x0000开始，并且把 GDT 和 IDT 表创建好，应用程序在内存的上端

都是为了读入初始化

## 二、操作系统接口

### 1. 接口

- 连接两个东西
- 信号转换
- 屏蔽细节

### 2. 用户使用计算机

- 命令行
  - 用C语言写的程序而已
- 图形按钮
  - 消息机制
  - 一个包括画图的C程序
- 应用程序

### 3. 系统调用

- system_call
- 标准制定：POSIX

## 三、系统调用的实现

### 1. 直观实现

- 不能随意的调用数据，不能随意的jmp。
- CPL>DPL，CPL=3、DPL=0，此时不能进行系统调用
- int指令将使CS中的CPL改成0，“进入内核”
- 中断是进入内核的唯一方法
- 用户调用printf ==> printf展成 int 0x80 ==> 中断处理 system_call ==> 查表 sys_call_table ==> __NR_write = 4 ==> 调用 system_write



## 四、操作系统历史

- CP/M ==> QDOS ==> MS-DOS ==> Windows
- Unix ==> System ==> Mac OS ==> IOS

- 掌握、实现操作系统的多进程图谱
- 掌握、实现操作系统的文件操作视图



## 五、CPU管理

- 工作原理
  - 自动的取指--执行
- 多道程序，交替执行
- 一个CPU上交替的执行多个程序：并发
- 怎么做？
  - 修改寄存器PC
  - 记录返回地址
    - 存放信息的结构：PCB（Process Control Block）
- 运行的程序（进程）和静态程序不一样
  - 程序 + 所有这些不一样 -》 一个概念
- 进程是进行（执行）中的程序
  - 进程有开始、有结束，程序没有
  - 程序会走走停停，走停对程序无意义
  - 进程需要记录ax,bx,....，程序不用



## 六、多进程图像

- 多进程图像从启动开始到关机结束

- 多进程如何组织

  - PCB形成就绪队列：有一些进程等待执行
  - 磁盘等待队列：有一些进程在等待某事件

- 多进程的组织

  - 运行 --> 等待；运行 --> 就绪；就绪 --> 运行......

    ![](https://raw.githubusercontent.com/exzvm/Picture/main/image-20220313173450563.png)

  - 上图为进程状态图

  - 它能给出进程生存期的清晰描述

  - 它是认识操作系统进程管理的一个窗口

- 多进程如何交替？

  ```c
  schedule()
  {
      pNew = getNext(ReadyQueue); // 调度
      switch_to(pCur, pNew); // PCB
  }
  ```

- 交替的三个部分：队列操作 + 调度 + 切换

  - FIFO
    - 公平的策略
    - 没有考虑进程执行的任务的区别
  - Priority

- 多进程的地址空间分离：内存管理的主要内容

  - 映射表

- 多进程合作

- 如何形成多进程图像

  - 读写PCB
  - 操作寄存器完成切换
  - 写调度程序
  - 有进程同步与合作
  - 有地址映射

## 七、用户级进程

- 进程 = 资源 + 指令执行序列

  - 将资源和指令执行分开
  - 一个资源 + 多个指令执行序列

- 线程

  - 保留了并发的优点，避免了进程切换的代价
  - 实质就是映射表不变而PC指针变

- 多个执行序列 + 一个地址空间是否使用？

  - 一个网页浏览器

    - 一个线程用来从服务器接收数据
    - 一个线程用来显示文本
    - 一个线程用来处理图片（如解压缩）
    - 一个线程用来显示图片

  - 这些线程要共享资源吗？

    - 接收数据放在100处，显示时要读
    - 所有的文本、图片都显示在一个屏幕上

  - 实现

    ```c
    void WebExplorer()
    {
        char URL[] = "http://cms.hit.edu.cn";
        char buffer[1000];
        pthread_create(..., GetData, URL, buffer);
        pthread_create(..., Show, buffer);
    }
    void GetData(char *URL, char *p) {...};
    void Show(char *p) {...};
    ```

  - Create、Yield

    - 核心是 Yield
      - 得知道切换时是什么样子
      
      - Create就是要制造出第一次切换时的样子
      
        ```c
        void Yield() {
            TCB2.esp = esp;
            esp = TCB1.esp;
            jmp 204;
        }
        ```
      
      - TCB(Thread Control Block：线程控制块)
      
    - 从一个栈到两个栈

      - Yield切换要先切换栈

    - 两个线程的样子：两个TCB、两个栈、切换的PC在栈中

      - ThreadCreate的核心就是用程序做出这三样东西

        ```c
        void ThreadCreate(A)
        {
            TCB *tcb = malloc();
            *stack = malloc();
            *stack = A;
            tcb.esp = stack;
        }
        ```

    - Yield是用户程序

  

## 八、内核级线程

- 核心级线程
  
  - 一个栈到一套栈；两个栈到两套栈
  
- 用户栈和内核栈之间的不同
  
  - ThreadCreate是系统调用，内核管理TCB，内核负责切换线程
  
- 用户栈和内核栈之间的关联

  - 用户栈  ----(int)-----> 内核栈
  - 所有的中断（时钟，外设，INT指令）都引起上述转换
  - 内核栈  ----(iret)-----> 用户栈

- 开始内核中的切换：switch_to

  - 仍然是通过TCB找到内核栈指针；然后通过**ret切到**某个内核程序；最后再用**CS:PC切到**用户程序

  - CS:PC后面的代码一段能完成第二级返回的代码，一段包含iret的代码...

    ![image-20220319175522313](操作系统.assets/image-20220319175522313.png)

- 内核线程switch_to的五段论

  - 中断入口：（进入切换）

    ```c
    push ds;... pusha;
    mov ds, 内核段号; ...
    call 中断处理
    ??:
    ```

  - 中断处理：（引发切换）

    ```c
    schedule();
    ```

  - schedule：next=..

    ```c
    call switch_to;
    ```

  - switch_to：（内核栈切换）

    ```c
    TCB[cur].esp=%esp;
    %esp=TCB[next].esp;
    ret
    ```

  - 中断出口：（第二级切换）

    ```c
    popa;...; pop ds;
    iret
    ```

- 用户级线程、核心级线程的对比

  |            | 用户级线程 | 核心级线程 | 用户+核心 |
  | ---------- | ---------- | ---------- | --------- |
  | 利用多核   | 差         | 好         | 好        |
  | 并发度     | 低         | 高         | 高        |
  | 代价       | 小         | 大         | 中        |
  | 内核改动   | 无         | 大         | 大        |
  | 用户灵活性 | 大         | 小         | 大        |



## 九、内核级线程实现

